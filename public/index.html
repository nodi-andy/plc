<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="HandheldFriendly" content="true" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="noditron" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>noditron</title>
    <style>
      html,
      body {
        margin: 0 !important;
        padding: 0 !important;
        height: 100%;
        width: 100%;
      }

      .lgraphcanvas {
        /*cursor: crosshair;*/
        user-select: none;
        -moz-user-select: none;
        -webkit-user-select: none;
        outline: none;
        font-family: Tahoma, sans-serif;
      }

      .lgraphcanvas * {
        box-sizing: border-box;
      }

      /* Styles for high-DPI screens */
      @media only screen and (-webkit-min-device-pixel-ratio: 2),
        only screen and (min--moz-device-pixel-ratio: 2),
        only screen and (min-resolution: 192dpi),
        only screen and (min-resolution: 2dppx) {
      }
    </style>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
  <script type="module">
    const loadJS = (FILE_URL, async = true, type = "module") => {
      return new Promise((resolve, reject) => {
        try {
          const scriptEle = document.createElement("script");
          scriptEle.type = type;
          scriptEle.async = async;
          scriptEle.src = FILE_URL;

          scriptEle.addEventListener("load", (ev) => {
            resolve({ status: true });
          });

          scriptEle.addEventListener("error", (ev) => {
            reject({
              status: false,
              message: `Failed to load the script ï¼„{FILE_URL}`,
            });
          });

          document.body.appendChild(scriptEle);
        } catch (error) {
          reject(error);
        }
      });
    };
    // why loading the scripts one by one?
    // Because the IoT device can not keep more than 10 TCP connections open
    await loadJS("./socket.io.min.js", false);
    await loadJS("./math.js", false);
    await loadJS("./nodework.mjs", false);
    await loadJS("./node.mjs", false);
    await loadJS("./view.js", false);
    await loadJS("./nodes/basic/button.mjs", false);
    await loadJS("./nodes/basic/toggle.mjs", false);
    await loadJS("./nodes/basic/led.mjs", false);
    await loadJS("./nodes/basic/number.mjs", false);
    await loadJS("./nodes/basic/subnode.mjs", false);
    await loadJS("./nodes/logic/and.mjs", false);
    await loadJS("./nodes/logic/or.mjs", false);
    await loadJS("./nodes/logic/xor.mjs", false);
    await loadJS("./nodes/logic/not.mjs", false);
    await loadJS("./nodes/math/add.mjs", false);
    await loadJS("./nodes/math/mult.mjs", false);
    await loadJS("./nodes/math/isequal.mjs", false);
    await loadJS("./nodes/math/isless.mjs", false);
    await loadJS("./nodes/math/isgreater.mjs", false);
    await loadJS("./nodes/time/interval.mjs", false);
    await loadJS("./nodes/basic/inserter.mjs", false);
    await loadJS("./nodes/nodi.box/b1.js", false);
    await loadJS("./nodes/nodi.box/b2.js", false);
    await loadJS("./nodes/nodi.box/b3.js", false);
    await loadJS("./nodes/nodi.box/b4.js", false);
    await loadJS("./nodes/nodi.box/yellow.js", false);
    await loadJS("./nodes/nodi.box/green.js", false);
    await loadJS("./nodes/nodi.box/stepper.js", false);
    await loadJS("./nodes/esp32mcu/b1.js", false);
    await loadJS("./nodes/esp32mcu/led.js", false);
    await loadJS("./nodes/remote/serial.mjs", false);
    
    import Node from "./node.mjs";
    import NodeWork from "./nodework.mjs";
    import Canvas from "./canvas.js";
    import { NodiEnums } from "./enums.mjs";

    
    window.nodeWork = new NodeWork();
    /*window.nodeWork.engine = {name: "server", send: (order) => {
      console.log("forwardCMD: ", order);
      if (window.socket?.emit && window.socket.connected == true) { // send to server
        window.socket.emit(order.cmd, order.data);
      } 
    }};*/

    //window.nodeWork.engine = {name: "server", send: (order) => {
    //  console.log("forwardCMD: ", order);
      // if (websocket.send && websocket.readyState == 1) { // send to IoT
        //  websocket.send(JSON.stringify([cmd, obj]));
        // } 
    //}};

    await loadJS("./websocket.js", false);
    navigator.serial.getPorts().then((ports) => {
      if (ports.length) window.serialport = ports[0];
    });

    window.canvas = new Canvas("#mycanvas", window.nodeWork);
    window.nodeworkID = window.location.search.slice(1);
    window.sendToNodework = (cmd, obj) => {
      window.nodeWork.cmd({cmd: cmd, data: obj});
    };
    window.nodes = {};

    window.createNewNode = (type) => {
      let allowNode = true;

      if (type == "remote/serial" && window.serialport) {
          window.serialbuffer = "";
          window.serialport.open({ baudRate: 115200 }).then(() => {
            console.log('Port is opened!');
            window.reader = window.serialport.readable.getReader();
            window.serialwriter = window.serialport.writable.getWriter();

            const readLoop = () => {
              window.reader.read().then(({ value, done }) => {
                    if (done) {
                        console.log('Stream closed or reader released.');
                        return;
                    }
                    const receivedData = new TextDecoder().decode(value);
                    //console.log('Data received:', receivedData);
                    window.serialbuffer += receivedData;
                    let newlineIndex = window.serialbuffer.indexOf('\n');
                    while (newlineIndex !== -1) {
                        // Extract the line including the newline character
                        let line = window.serialbuffer.substring(0, newlineIndex + 1);
                        // Call the function with the extracted line
                        if (window.serialline) window.serialline(line);

                        // Remove the processed line from the buffer
                        window.serialbuffer = window.serialbuffer.substring(newlineIndex + 1);

                        // Check for another newline character in the remaining buffer
                        newlineIndex = window.serialbuffer.indexOf('\n');
                    }
                    // Continue reading
                    readLoop();
                }).catch(error => {
                    console.error('Error reading from serial port:', error);
                });
            };
            readLoop();
          });
      } 
      if (type == "remote/serial" && window.serialport == null) {
        allowNode = false
      }

      if (allowNode) {
        var msg = {};
        msg.type = type;
        msg.type = msg.type.toLowerCase();
        msg.pos = window.canvas.gridPos;
        var base_class = NodeWork.getNodeType(msg.type);
        if (!base_class) {
          if (NodeWork.debug) console.log('GraphNode type "' + msg.type + '" not registered.');
          return null;
        }

        msg.node = {};
        msg.node.type = msg.type;
        msg.node.properties = {};
        msg.node.orders = [];

        base_class.setup(msg.node);
        msg.node.size = [NodiEnums.CANVAS_GRID_SIZE, NodiEnums.CANVAS_GRID_SIZE];
        
        for (var i in msg.options) {
          msg.node.properties[i] = msg.options[i];
        }
        msg.node.nodeID = NodeWork.getFirstNullIndex(window.nodeWork.nodes);
        return msg;
      }
    };
    window.toParent = () => {
      window.showParent(false);
      if (window.nodeWork.parent) {
        window.nodeWork = window.nodeWork.parent;
        window.canvas.setGraph(window.nodeWork);
        window.showParent(true);
      }
    }
    window.nodes.copyNode = () => {
      if (window.canvas.copyNode == null && window.canvas.current_node)
        window.canvas.copyNode = window.canvas.current_node.nodeID;
      else window.canvas.copyNode = null;
    };

    window.nodes.editNode = () => {
      window.canvas.processContextMenu();
    };

    window.nodes.saveNodework = () => {
      window.sendToNodework("save", {});
    };

    window.nodes.upload = () => {
      if (window.socket) {
        let storeGraph = JSON.parse(JSON.stringify(window.nodeWork.serialize()));
        delete storeGraph.config;
        for (let n in storeGraph.nodes) {
          let node = storeGraph.nodes[n];
        }
        window.sendToNodework("setNodework", storeGraph);
        window.showSnackbar("nodework sent to nodi.box!");
      }
    };

    window.nodes.updateInputs = (id, changedNodeData) => {
      //if (isNaN(changedNodeData.inpValue) == false) changedNodeData.inpValue = parseInt(changedNodeData.inpValue);
      window.nodeWork.cmd({cmd: "updateInputs", data: {
        nodeID: id,
        properties: parseInt(changedNodeData),
      }});
    };

    window.nodes.update = (id, changedNodeData) => {
      window.sendToNodework("updateNode", {
        nodeID: id,
        properties: changedNodeData,
      });
    };

    window.load = (filename) => {
      window.nodeWork.setNodework(JSON.parse(localStorage[filename]));
      window.showSnackbar("Loaded nodework: " + filename);
    };

    localStorage.version = "0.2";
    if (localStorage.files == null) localStorage.files = JSON.stringify({});

    window.canvas.onSelectionChange = (nodes) => {
      if (Object.keys(nodes).length == 1) {
        let node = nodes[Object.keys(nodes)[0]]; // selected nodes are not indexed correctly
        window.showRemove(true);
        window.showEdit(true);
        window.showRotate(NodeWork.getNodeType(node.type).rotatable);
        window.showAdd(!Boolean(NodeWork.getNodeType(node.type).singleton));
        console.log("disable");
      } else {
        window.showAdd(false);
        window.showRotate(false);
        window.showRemove(false);
        window.showEdit(false);
        console.log("enable");
      }
    };

    window.addEventListener("resize", function () {
      canvas.resize();
    });

    window.updateNodeList = () => {
      window.nodes.list = {};
      for (let nodeClassName in NodeWork.registered_node_types) {
        let nodeClass = NodeWork.registered_node_types[nodeClassName];
        if (window.nodes.list[nodeClass.category] == null) window.nodes.list[nodeClass.category] = [];
        window.nodes.list[nodeClass.category].push(nodeClass.elementName);
      }
    };
    updateNodeList();

    setInterval(() => {
      if (window.nodeWork) {
        window.nodeWork.run();
      }
    }, 20);
    window.load("nodework");
  </script>
</html>
